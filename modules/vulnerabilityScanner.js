import axios from 'axios';
import * as cheerio from 'cheerio';

export class VulnerabilityScanner {
  constructor() {
    this.userAgent = 'DevXploit-Security-Scanner/1.0';
  }

  // Helper function to safely parse URLs
  safeUrlParse(url) {
    try {
      return new URL(url);
    } catch (error) {
      console.log(`URL parsing failed for ${url}:`, error.message);
      return null;
    }
  }

  async scanForVulnerabilities(url) {
    const vulnerabilities = [];
    
    try {
      console.log(`üîç Starting vulnerability scan for: ${url}`);
      
      // Run multiple vulnerability checks
      const xssCheck = await this.checkXSS(url);
      console.log(`XSS check found ${xssCheck.length} issues`);
      
      const sqlInjectionCheck = await this.checkSQLInjection(url);
      console.log(`SQL injection check found ${sqlInjectionCheck.length} issues`);
      
      const directoryTraversalCheck = await this.checkDirectoryTraversal(url);
      console.log(`Directory traversal check found ${directoryTraversalCheck.length} issues`);
      
      const openRedirectCheck = await this.checkOpenRedirect(url);
      console.log(`Open redirect check found ${openRedirectCheck.length} issues`);
      
      const sensitiveFilesCheck = await this.checkSensitiveFiles(url);
      console.log(`Sensitive files check found ${sensitiveFilesCheck.length} issues`);
      
      vulnerabilities.push(...xssCheck);
      vulnerabilities.push(...sqlInjectionCheck);
      vulnerabilities.push(...directoryTraversalCheck);
      vulnerabilities.push(...openRedirectCheck);
      vulnerabilities.push(...sensitiveFilesCheck);

      console.log(`üö® Total vulnerabilities found: ${vulnerabilities.length}`);
      
      return {
        vulnerabilities,
        totalFound: vulnerabilities.length,
        severity: this.calculateSeverity(vulnerabilities)
      };
    } catch (error) {
      console.error('Vulnerability scan error:', error);
      throw new Error(`Vulnerability scan failed: ${error.message}`);
    }
  }

  async checkXSS(url) {
    const vulnerabilities = [];
    const xssPayloads = [
      '<script>alert("XSS")</script>',
      '"><script>alert("XSS")</script>',
      "';alert('XSS');//",
      '<img src=x onerror=alert("XSS")>'
    ];

    try {
      const response = await axios.get(url, { timeout: 5000 });
      const $ = cheerio.load(response.data);
      
      // Check for forms that might be vulnerable to XSS
      const forms = $('form');
      
      for (let i = 0; i < forms.length; i++) {
        const form = forms.eq(i);
        const action = form.attr('action') || url;
        const method = form.attr('method') || 'GET';
        
        // Look for input fields
        const inputs = form.find('input[type="text"], input[type="search"], textarea');
        
        if (inputs.length > 0) {
          vulnerabilities.push({
            type: 'Cross-Site Scripting (XSS)',
            severity: 'High',
            location: action,
            description: 'Form inputs may be vulnerable to XSS attacks',
            evidence: `Form with ${inputs.length} text input(s) found`,
            remediation: 'Implement input validation, output encoding, and Content Security Policy (CSP)'
          });
        }
      }

      // Check for reflected parameters in URL
      const urlObj = this.safeUrlParse(url);
      if (urlObj && urlObj.searchParams.size > 0) {
        vulnerabilities.push({
          type: 'Potential Reflected XSS',
          severity: 'Medium',
          location: url,
          description: 'URL parameters detected that could be vulnerable to reflected XSS',
          evidence: `URL contains ${urlObj.searchParams.size} parameter(s)`,
          remediation: 'Validate and sanitize all URL parameters before displaying them'
        });
      }

    } catch (error) {
      console.log(`XSS check error for ${url}:`, error.message);
    }

    return vulnerabilities;
  }

  async checkSQLInjection(url) {
    const vulnerabilities = [];
    const sqlPayloads = [
      "' OR '1'='1",
      "'; DROP TABLE users; --",
      "' UNION SELECT * FROM users --",
      "1' AND 1=1 --"
    ];

    try {
      const response = await axios.get(url, { timeout: 5000 });
      const $ = cheerio.load(response.data);
      
      // Check for forms with database-related inputs
      const forms = $('form');
      
      for (let i = 0; i < forms.length; i++) {
        const form = forms.eq(i);
        const inputs = form.find('input[type="text"], input[type="email"], input[type="password"]');
        
        // Look for login/search forms that might query databases
        const hasLoginInputs = form.find('input[type="password"]').length > 0;
        const hasSearchInputs = form.find('input[name*="search"], input[placeholder*="search"]').length > 0;
        
        if (hasLoginInputs || hasSearchInputs) {
          vulnerabilities.push({
            type: 'Potential SQL Injection',
            severity: 'High',
            location: form.attr('action') || url,
            description: 'Form may be vulnerable to SQL injection attacks',
            evidence: hasLoginInputs ? 'Login form detected' : 'Search form detected',
            remediation: 'Use parameterized queries/prepared statements, input validation, and least privilege database access'
          });
        }
      }

      // Check URL parameters for potential SQL injection points
      const urlObj = this.safeUrlParse(url);
      if (urlObj) {
        const suspiciousParams = ['id', 'user', 'search', 'q', 'query'];
        
        for (const param of urlObj.searchParams.keys()) {
          if (suspiciousParams.some(suspicious => param.toLowerCase().includes(suspicious))) {
            vulnerabilities.push({
              type: 'Potential SQL Injection via URL Parameter',
              severity: 'Medium',
            location: url,
            description: `URL parameter '${param}' may be vulnerable to SQL injection`,
            evidence: `Suspicious parameter: ${param}`,
            remediation: 'Validate and sanitize URL parameters, use parameterized queries'
          });
        }
      }
      }

    } catch (error) {
      console.log(`SQL injection check error for ${url}:`, error.message);
    }

    return vulnerabilities;
  }

  async checkDirectoryTraversal(url) {
    const vulnerabilities = [];
    const traversalPaths = [
      '../../../etc/passwd',
      '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
      '../../../../../../../etc/passwd',
      '....//....//....//etc/passwd'
    ];

    try {
      const urlObj = this.safeUrlParse(url);
      if (!urlObj) return vulnerabilities;
      
      const baseUrl = urlObj.origin;
      
      // Check for file parameter in URL
      const fileParams = ['file', 'path', 'dir', 'document', 'page', 'include'];
      
      for (const param of urlObj.searchParams.keys()) {
        if (fileParams.some(fileParam => param.toLowerCase().includes(fileParam))) {
          vulnerabilities.push({
            type: 'Potential Directory Traversal',
            severity: 'High',
            location: url,
            description: `Parameter '${param}' may be vulnerable to directory traversal attacks`,
            evidence: `File-related parameter detected: ${param}`,
            remediation: 'Validate file paths, use whitelist of allowed files, implement proper access controls'
          });
        }
      }

    } catch (error) {
      // Ignore connection errors
    }

    return vulnerabilities;
  }

  async checkOpenRedirect(url) {
    const vulnerabilities = [];
    
    try {
      const urlObj = this.safeUrlParse(url);
      if (!urlObj) return vulnerabilities;
      const redirectParams = ['redirect', 'url', 'return', 'returnUrl', 'next', 'continue'];
      
      for (const param of urlObj.searchParams.keys()) {
        if (redirectParams.some(redirectParam => param.toLowerCase().includes(redirectParam))) {
          vulnerabilities.push({
            type: 'Potential Open Redirect',
            severity: 'Medium',
            location: url,
            description: `Parameter '${param}' may be vulnerable to open redirect attacks`,
            evidence: `Redirect parameter detected: ${param}`,
            remediation: 'Validate redirect URLs against whitelist, use relative URLs when possible'
          });
        }
      }

    } catch (error) {
      // Ignore connection errors
    }

    return vulnerabilities;
  }

  async checkSensitiveFiles(url) {
    const vulnerabilities = [];
    const sensitiveFiles = [
      '.env',
      'config.php',
      'wp-config.php',
      '.git/config',
      'robots.txt',
      'sitemap.xml',
      'admin',
      'admin.php',
      'login',
      'phpmyadmin'
    ];

    try {
      const urlObj = this.safeUrlParse(url);
      if (!urlObj) return vulnerabilities;
      
      const baseUrl = urlObj.origin;
      
      for (const file of sensitiveFiles.slice(0, 5)) { // Limit checks to avoid timeout
        try {
          const testUrl = `${baseUrl}/${file}`;
          const response = await axios.get(testUrl, { 
            timeout: 3000,
            validateStatus: () => true 
          });
          
          if (response.status === 200 && response.data.length > 0) {
            vulnerabilities.push({
              type: 'Sensitive File Exposure',
              severity: file.includes('.env') || file.includes('config') ? 'High' : 'Medium',
              location: testUrl,
              description: `Sensitive file '${file}' is accessible`,
              evidence: `HTTP ${response.status} response received`,
              remediation: 'Remove or restrict access to sensitive files, configure proper server rules'
            });
          }
        } catch (error) {
          // File not accessible (which is good)
        }
      }

    } catch (error) {
      // Ignore connection errors
    }

    return vulnerabilities;
  }

  calculateSeverity(vulnerabilities) {
    if (vulnerabilities.length === 0) return { level: 'Low', score: 85 };
    
    let criticalCount = 0;
    let highCount = 0;
    let mediumCount = 0;
    let lowCount = 0;

    vulnerabilities.forEach(vuln => {
      switch (vuln.severity) {
        case 'Critical': criticalCount++; break;
        case 'High': highCount++; break;
        case 'Medium': mediumCount++; break;
        case 'Low': lowCount++; break;
      }
    });

    // Calculate score (100 is perfect, lower is worse)
    let score = 100;
    score -= criticalCount * 25;
    score -= highCount * 15;
    score -= mediumCount * 8;
    score -= lowCount * 3;
    
    score = Math.max(0, score);

    let level = 'Low';
    if (criticalCount > 0 || score < 30) level = 'Critical';
    else if (highCount > 0 || score < 50) level = 'High';
    else if (mediumCount > 0 || score < 70) level = 'Medium';

    return { level, score, criticalCount, highCount, mediumCount, lowCount };
  }
}